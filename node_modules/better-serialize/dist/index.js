"use strict";
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Serialize: () => Serialize,
  parse: () => parse,
  stringify: () => stringify
});
module.exports = __toCommonJS(src_exports);

// src/lib/private/isObject.ts
function isObject(value) {
  return typeof value === "object" && value?.constructor === Object;
}
__name(isObject, "isObject");

// src/lib/Serialize.ts
var Serialize;
((Serialize2) => {
  function toJsonCompatible(data) {
    if (isObject(data))
      return { [Keying.Type]: Type.Object, [Keying.Value]: toJsonCompatibleObject(data) };
    else if (typeof data === "string")
      return { [Keying.Type]: Type.String, [Keying.Value]: data };
    else if (typeof data === "number") {
      if (Number.isNaN(data))
        return { [Keying.Type]: Type.Number, [Keying.Value]: "NaN" };
      if ([Infinity, -Infinity].includes(data))
        return { [Keying.Type]: Type.Number, [Keying.Value]: String(data) };
      return { [Keying.Type]: Type.Number, [Keying.Value]: data };
    } else if (typeof data === "boolean")
      return { [Keying.Type]: Type.Boolean, [Keying.Value]: data };
    else if (Array.isArray(data))
      return { [Keying.Type]: Type.Array, [Keying.Value]: toJsonCompatibleArray(data) };
    else if (data === null)
      return { [Keying.Type]: Type.Null };
    else if (data instanceof Date)
      return { [Keying.Type]: Type.Date, [Keying.Value]: data.toJSON() };
    else if (data === void 0)
      return { [Keying.Type]: Type.Undefined };
    else if (typeof data === "bigint")
      return { [Keying.Type]: Type.BigInt, [Keying.Value]: data.toString() };
    else if (data instanceof RegExp) {
      return { [Keying.Type]: Type.RegExp, [Keying.Value]: { [Keying.Source]: data.source, [Keying.Flags]: data.flags } };
    } else if (data instanceof Map)
      return { [Keying.Type]: Type.Map, [Keying.Value]: toJsonCompatibleEntries(Array.from(data)) };
    else if (data instanceof Set)
      return { [Keying.Type]: Type.Set, [Keying.Value]: toJsonCompatibleArray(Array.from(data)) };
    throw new TypeError(`Serialize received an unknown type while formatting: "${data.constructor.name}".`);
  }
  Serialize2.toJsonCompatible = toJsonCompatible;
  __name(toJsonCompatible, "toJsonCompatible");
  function toJsonCompatibleArray(array) {
    const json = [];
    for (const value of array)
      json.push(toJsonCompatible(value));
    return json;
  }
  __name(toJsonCompatibleArray, "toJsonCompatibleArray");
  function toJsonCompatibleEntries(entries) {
    const json = [];
    for (const [key, value] of entries)
      json.push([key, toJsonCompatible(value)]);
    return json;
  }
  __name(toJsonCompatibleEntries, "toJsonCompatibleEntries");
  function toJsonCompatibleObject(object) {
    const json = {};
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        json[key] = toJsonCompatible(object[key]);
      }
    }
    return json;
  }
  __name(toJsonCompatibleObject, "toJsonCompatibleObject");
  function fromJsonCompatible(json) {
    const { [Keying.Type]: type, [Keying.Value]: value } = json;
    switch (type) {
      case Type.Array:
        return fromJsonCompatibleArray(value);
      case Type.BigInt:
        return BigInt(value);
      case Type.Boolean:
        return value;
      case Type.Date:
        return new Date(value);
      case Type.Map:
        return new Map(fromJsonCompatibleMap(value));
      case Type.Null:
        return null;
      case Type.Number:
        if (typeof value === "string")
          return Number(value);
        return value;
      case Type.Object:
        return fromJsonCompatibleObject(value);
      case Type.RegExp:
        return new RegExp(value[Keying.Source], value[Keying.Flags]);
      case Type.Set:
        return new Set(fromJsonCompatibleArray(value));
      case Type.String:
        return value;
      case Type.Undefined:
        return void 0;
      default:
        throw new TypeError("Serialize received an unknown type.");
    }
  }
  Serialize2.fromJsonCompatible = fromJsonCompatible;
  __name(fromJsonCompatible, "fromJsonCompatible");
  function fromJsonCompatibleArray(json) {
    const arr = [];
    for (const value of json)
      arr.push(fromJsonCompatible(value));
    return arr;
  }
  __name(fromJsonCompatibleArray, "fromJsonCompatibleArray");
  function fromJsonCompatibleMap(json) {
    const arr = [];
    for (const [key, value] of json)
      arr.push([key, fromJsonCompatible(value)]);
    return arr;
  }
  __name(fromJsonCompatibleMap, "fromJsonCompatibleMap");
  function fromJsonCompatibleObject(json) {
    const obj = {};
    for (const key in json) {
      if (Object.prototype.hasOwnProperty.call(json, key)) {
        obj[key] = fromJsonCompatible(json[key]);
      }
    }
    return obj;
  }
  __name(fromJsonCompatibleObject, "fromJsonCompatibleObject");
  let Keying;
  ((Keying2) => {
    Keying2["Type"] = "t";
    Keying2["Value"] = "v";
    Keying2["Source"] = "s";
    Keying2["Flags"] = "f";
  })(Keying = Serialize2.Keying || (Serialize2.Keying = {}));
  let Type;
  ((Type2) => {
    Type2[Type2["Array"] = 4] = "Array";
    Type2[Type2["BigInt"] = 8] = "BigInt";
    Type2[Type2["Boolean"] = 3] = "Boolean";
    Type2[Type2["Date"] = 6] = "Date";
    Type2[Type2["Map"] = 10] = "Map";
    Type2[Type2["Null"] = 5] = "Null";
    Type2[Type2["Number"] = 2] = "Number";
    Type2[Type2["Object"] = 0] = "Object";
    Type2[Type2["RegExp"] = 9] = "RegExp";
    Type2[Type2["Set"] = 11] = "Set";
    Type2[Type2["String"] = 1] = "String";
    Type2[Type2["Undefined"] = 7] = "Undefined";
  })(Type = Serialize2.Type || (Serialize2.Type = {}));
})(Serialize || (Serialize = {}));

// src/lib/parse.ts
function parse(data) {
  return Serialize.fromJsonCompatible(JSON.parse(data));
}
__name(parse, "parse");

// src/lib/stringify.ts
function stringify(data) {
  return JSON.stringify(Serialize.toJsonCompatible(data));
}
__name(stringify, "stringify");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Serialize,
  parse,
  stringify
});
//# sourceMappingURL=index.js.map